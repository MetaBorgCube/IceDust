module dirtysupers

// used features (initsupers):
// - extending a trait
// - incremental attribute using parent field (dirty flagging needs to type filter)
// - derived value in trait as well (requires initing derived values in all super types)
// extra:
// - override derivation expression in subtype + depend on both super type and subtype definition (needs to dirty flag from both definitions)

// compilation to inheritance (idem initsupers):
// - not compile all _visible_ fields in class, only fields _defined_ in that class
// - use extends
// - only call init for _defined_ fields (currently _visible_) in constructor, super constructors are called implicitly already
// extra:
// - dirtyflagsflowsto has to call super
// - for overriding _defined_ fields, only generate getter/calculate

// compilation to default methods (idem initsupers):
// - not compile all _visible_ fields in class, only fields _defined_ in that class
// - make interface + all non-static methods public default
// - make interface require getInternalX() and setInternal(x) + use those in the method implementations + implement these methods in concrete class
// - dirty collection needs to be in concrete companion class
// - static getters in all classes OR call them on correct type (where the field is first defined) (not an issue with inheritance, because one can call static methods that resolve to a super type)
// - init methods only _defined_ fields that have no super type, call the super inits()
// extra:
// - dirtyflagsflowsto has to call super
// - for overriding _defined_ fields, only generate getter/calculate

// compilation to interfaces (idem initsupers):
// - compile all visible fields in class (entities)
// - for all defined fields getters (traits)
// - dirty collection + static methods need to be in concrete companion class
// - static getters in all classes OR call them on correct type (where the field is first defined)
// - init calls in constructors for all visible fields (already correct)

model

  trait CountTen2 {
    ten    : Int = 1 + 2 + 3 + 4 
    thirty : Int = ten * 3
  }
  
  entity UseCountTen2 extends CountTen2 {
    ten    : Int = 10
    twenty : Int = ten * 2
  }

data

  twenty:UseCountTen2{}
  
execute

  twenty.ten
  twenty.twenty
  twenty.thirty
