module expressions-functions

rules
  
  //TODO: Move all function signatures to root-scope, and make a single Function() rule.
  //      However, we need to wait till NaBL2 supports overload resolution.
  
  [[ Function("min", [e1]) ^ (s) : TTuple(e1_type, out_mult, e1_strat) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    e1_type <test? IsNumeric(),
    out_mult is upperboundOne of e1_mult,
    e1_mult_u is multUpper of e1_mult,
    e1_mult_u == TUMany() | error $[Expected multiplicity of higher than One] @ e1.
    
  [[ Function("max", [e1]) ^ (s) : TTuple(e1_type, out_mult, e1_strat) ]] := // identical to Min
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    e1_type <test? IsNumeric(),
    out_mult is upperboundOne of e1_mult,
    e1_mult_u is multUpper of e1_mult,
    e1_mult_u == TUMany() | error $[Expected multiplicity of higher than One] @ e1.
    
  [[ Function("avg", [e1]) ^ (s) : TTuple(e1_type, out_mult, e1_strat) ]] := // identical to Min
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    e1_type <test? IsNumeric(),
    out_mult is upperboundOne of e1_mult,
    e1_mult_u is multUpper of e1_mult,
    e1_mult_u == TUMany() | error $[Expected multiplicity of higher than One] @ e1.
    
  [[ Function("sum", [e1]) ^ (s) : TTuple(e1_type, TOne(), e1_strat) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    e1_type <test? IsNumeric(),
    e1_mult_u is multUpper of e1_mult,
    e1_mult_u == TUMany() | error $[Expected multiplicity of higher than One] @ e1.
    
  [[ Function("conj", [e1]) ^ (s) : TTuple(e1_type, TOne(), e1_strat) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    e1_type <test? IsBoolean(),
    e1_mult_u is multUpper of e1_mult,
    e1_mult_u == TUMany() | error $[Expected multiplicity of higher than One] @ e1.

  [[ Function("disj", [e1]) ^ (s) : TTuple(e1_type, TOne(), e1_strat) ]] := // identical to Conj
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    e1_type <test? IsBoolean(),
    e1_mult_u is multUpper of e1_mult,
    e1_mult_u == TUMany() | error $[Expected multiplicity of higher than One] @ e1.

  [[ Function("concat", [e1]) ^ (s) : TTuple(e1_type, TOne(), e1_strat) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    e1_type <test? IsString(),
    e1_mult_u is multUpper of e1_mult,
    e1_mult_u == TUMany() | error $[Expected multiplicity of higher than One] @ e1.

  [[ Function("count", [e1]) ^ (s) : TTuple(TInt(), TOne(), e1_strat) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    e1_type <test? IsType(). // make sure it evaluates to something

  [[ Function("first", [e1]) ^ (s) : TTuple(e1_type, out_mult, e1_strat) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    e1_mult_u is multUpper of e1_mult,
    TUMany() is multUpper of e1_mult | warning $[Multiplicity mismatch: Expected TUMany() got [e1_mult_u]]@e1,
    out_mult is upperboundOne of e1_mult.

  [[ Function("first", [e1, e2]) ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    [[ e2 ^ (s) : TTuple(e2_type, e2_mult, e2_strat) ]],
    e1_mult_u is multUpper of e1_mult,
    TUMany() is multUpper of e1_mult | warning $[Multiplicity mismatch: Expected TUMany() got [e1_mult_u]]@e1,
    e2_type == TInt() | error $[Type mismatch: expected Integer got [e2_type]]@e2,
    e2_mult == TOne() | error $[Multiplicity mismatch: expected One got [e2_type]]@e2,
    out_mult is upperboundOne of e1_mult.

  [[ Function("elemAt", [e1, e2]) ^ (s) : TTuple(e1_type, TZeroOrOne(), out_strat) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    [[ e2 ^ (s) : TTuple(e2_type, e2_mult, e2_strat) ]],
    e2_type == TInt() | error $[Type mismatch: expected Int got [e2_type]]@e2,
    e2_mult_upper is multUpper of e2_mult,
    e2_mult_upper == TUOne() | error $[Multiplicity mismatch: Expected One or ZeroOrOne got [e2_mult]]@e2,
    out_strat is strat.lub of (e1_strat, e2_strat).

  [[ Function("indexOf", [e1, e2]) ^ (s) : TTuple(TInt(), TZeroOrOne(), out_strat) ]] :=
    [[ e1 ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]],
    [[ e2 ^ (s) : TTuple(e2_type, e2_mult, e2_strat) ]],
    e1_type == e2_type | error $[Type mismatch: expected [e1_type] got [e2_type]]@e2,
    e2_mult_upper is multUpper of e2_mult,
    e2_mult_upper == TUOne() | error $[Multiplicity mismatch: Expected One or ZeroOrOne got [e2_mult]]@e2,
    out_strat is strat.lub of (e1_strat, e2_strat).
  
  // Catch all: depends on ordering within file!
  [[ Function(f, es) ^ (s) : TTuple(e1_type, e1_mult, e1_strat) ]] :=
    false | error $[No built-in function [f] with this number of operands.]@f.
 